# 作用域链与执行上下文

> 本文只代表个人理解, 没有从规范着手, 难免有疏漏之处, 请勿过于相信, 抱着怀疑的角度阅读即可

## 作用域链

ES6 之前 js 中是没有块级作用域的, 日常开发接触到的就是全局作用域以及函数作用域

但是作用域其实就是个概念, 实际的变量是挂载在变量对象(VO)上的, 也就是说, 内部会先创建一个对象, 然后将其他变量挂载上去, 最后运行的时候就能从作用域中取出变量, 像函数的入参, 内部的变量等等都是挂载在变量对象上;

而作用域链则是将一层层的作用域串联起来, 也就是说内部的作用域能够串联到最外面的作用域, 这样内部的作用域访问到最外部的作用域去, 但是最外面的作用域则只能访问自己的变量对象了;

全局作用域的变量对象就是全局对象, 而函数的作用域则包括内部的变量定义等等. 理论上来说当函数执行完之后, 内部的作用域就会被销毁掉, 但是当我们返回一个函数时, 这个函数的作用域链其实链接了外部的函数作用域, 这样当外部的函数执行完之后, 由于返回的函数还在使用, 外部的作用域就不会被销毁, 这也就是闭包, 变量会被一直激活, 销毁的时机则要看浏览器了;

## 执行上下文

执行上下文, 听名字就知道应该是执行的时候创建的执行环境, 每创建一个执行上下文就会将其放到执行栈中去, 这样浏览器就知道现在执行到哪了, 以及每个函数运行时的环境;

执行上下文包括三个部分:

- 作用域链;
- 变量对象
- this

作用域链以及变量对象其实差不多, 无非就是一个是外部的串联链, 一个是内部的作用域;

而 this 这个就有点玄学了, 很多文章都会讲解 this 的绑定规则啥的, 但是单纯的看 this 又不太好理解, 所以我们通过几个例子来讲解一下;

```js
function aaa() {
  console.log(this.text);
  let text = this.text;

  function bbb() {
    console.log(text);
    console.log(this.text);
  }

  const ccc = () => {
    console.log(this.text);
  };

  bbb();
  ccc();
}

let test = { text: "text", run: aaa };
test.run();
// text
// text
// undefined
// text
```

显然, 作用域跟定义函数的位置有关, 哪怕你将变量定义在外面, 我们也能通过作用域链访问到外部的变量, 这个很好理解, 毕竟作用域链就是这么设计的;

但是 this 就不跟作用域一样了, 它与定义的位置无关, 它与谁调用的函数有关;

当然我们可能会思考, 如果 this 就是运行时的外部作用域, 这样既能获取运行时的作用域又能获取定义时的作用域, 复用起来都很方便, 为啥不这么设计呢?

实际上这还是设计语法时的不同选择吧, 假如是 this 是运行时的作用域, 那么 js 就会变成动态作用域, 然后这样我们就不需要那么多的对象, 一切将以函数为主, 这显然与现在的大不一样;

而设计成与调用对象有关, 那就是面向对象的语法, 一切以对象为主, 链式调用就能将 this 不断的传递, 函数也是对象等等;

需要注意的是箭头函数其实是查找作用域链上一层的 this, 也就是定义箭头函数时的 this, 而不是运行时的 this, 这点需要注意下;

### this 的绑定

《你不知道的 js》 讲解了四种 this 绑定规则, 其实也就是判断 this 的指向, 这里也简单介绍下, 优先级从上到下依次加重:

- 默认绑定

默认指向 window, 严格模式下则是 undefined

- 隐式绑定

也就是函数作为对象的属性调用, 这个时候就会指向对象本身, 但是如果将对象属性重新赋值给一个变量再执行, 那么就会丢失 this

- 显示绑定

通过使用 bind, apply, call 去显式的改变 this;

- new 绑定

通过 new 创建一个对象, 这个时候构造函数中的 this 就是内部创建的新对象

## 附带

都知道 js 是动态语言, 没有预编译过程, 但是这并不代表浏览器没办法优化, 作用域链与调用环境无关, 所以浏览器先扫一遍, 给变量对象先赋值, 然后将作用域链串联起来, 这样即使还没执行, 但是已经将其载入内存了, 最后执行的时候将变量对象激活, 同时传入 this, 这样就能加快执行的速度;
